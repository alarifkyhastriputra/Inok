<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>UNO Multiplayer (HTML)</title>

  <!-- Tailwind CDN for styling -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React + ReactDOM via CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

  <!-- Babel for JSX (development only) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Firebase v9 compat (easier to use in plain HTML) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <style>
    /* small custom styles for card animation & flying card */
    .card {
      width: 72px;
      height: 104px;
      border-radius: 8px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      font-size:20px;
      user-select:none;
      box-shadow: 0 6px 18px rgba(2,6,23,0.15);
    }
    .card.small { width:56px; height:80px; font-size:16px; }
    .card.invalid { animation: shake 0.35s; }
    @keyframes shake {
      0% { transform: translateX(0); }
      20% { transform: translateX(-6px); }
      40% { transform: translateX(6px); }
      60% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
      100% { transform: translateX(0); }
    }

    /* flying card container */
    .flying {
      position: absolute;
      left: 50%;
      top: 36%;
      transform: translate(-50%, -50%);
      z-index: 60;
      transition: transform 0.6s ease-out, opacity 0.6s ease-out;
      pointer-events: none;
    }

    /* modal backdrop */
    .backdrop { background: rgba(0,0,0,0.55); }

    /* top card area */
    .top-card-area { width: 120px; height: 160px; }

  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-400 to-purple-600 flex items-center justify-center p-6">

  <div id="root" class="w-full max-w-6xl"></div>

  <script type="text/babel">

  const { useState, useEffect, useRef } = React;

  // ----- Firebase config (from your earlier message) -----
  const firebaseConfig = {
    apiKey: "AIzaSyAgOPD5DDtjExQaVeu6VLFI7CMP9i8VOQw",
    authDomain: "projectchat01-d16bc.firebaseapp.com",
    databaseURL: "https://projectchat01-d16bc-default-rtdb.firebaseio.com",
    projectId: "projectchat01-d16bc",
    storageBucket: "projectchat01-d16bc.appspot.com",
    messagingSenderId: "163313653543",
    appId: "1:163313653543:web:2319963fb69ffed211bb02",
    measurementId: "G-CKJ2L0WR4P"
  };

  // initialize firebase (compat)
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // ---- helpers ----
  const randomId = (prefix='id') => `${prefix}-${Math.random().toString(36).substr(2,9)}`;

  const playSound = (src) => {
    try {
      const a = new Audio(src);
      a.volume = 0.5;
      a.play().catch(()=>{ /* ignore autoplay block */ });
    } catch (e) { /* ignore */ }
  };

  // create full UNO deck (simple representation)
  const createDeck = () => {
    const colors = ['red','blue','green','yellow'];
    const deck = [];
    colors.forEach(color => {
      deck.push({ id: `${color}-0`, color, type: 'number', value: 0 });
      for (let i=1;i<=9;i++){
        deck.push({ id: `${color}-${i}-1`, color, type:'number', value:i });
        deck.push({ id: `${color}-${i}-2`, color, type:'number', value:i });
      }
      ['skip','reverse','draw2'].forEach(type => {
        deck.push({ id:`${color}-${type}-1`, color, type});
        deck.push({ id:`${color}-${type}-2`, color, type});
      });
    });
    for (let i=0;i<4;i++){
      deck.push({ id:`wild-${i}`, color:'wild', type:'wild' });
      deck.push({ id:`wild4-${i}`, color:'wild', type:'wild4' });
    }
    // shuffle
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
  };

  // ---- React App ----
  function App(){
    const [playerName, setPlayerName] = useState('');
    const [playerId, setPlayerId] = useState(randomId('p'));
    const [roomIdInput, setRoomIdInput] = useState('');
    const [currentRoom, setCurrentRoom] = useState(null);
    const [roomsList, setRoomsList] = useState([]);
    const [selectedCardIndex, setSelectedCardIndex] = useState(-1);
    const [showColorPicker, setShowColorPicker] = useState(false);
    const [selectedColorForWild, setSelectedColorForWild] = useState('red');
    const [invalidIndex, setInvalidIndex] = useState(null);
    const [flyingCard, setFlyingCard] = useState(null);
    const flyingTimeoutRef = useRef(null);

    // Listen available rooms (simple)
    useEffect(() => {
      const roomsRef = db.ref('rooms');
      roomsRef.on('value', snap => {
        const data = snap.val() || {};
        const arr = Object.keys(data).map(k => ({ id:k, ...data[k]}));
        setRoomsList(arr);
      });
      return () => roomsRef.off();
    }, []);

    // Listen current room changes
    useEffect(() => {
      if (!currentRoom?.id) return;
      const rref = db.ref(`rooms/${currentRoom.id}`);
      rref.on('value', snap => {
        const val = snap.val();
        if (val) {
          // attach id
          setCurrentRoom({ id: currentRoom.id, ...val });
        } else {
          setCurrentRoom(null);
        }
      });
      return () => rref.off();
    }, [currentRoom?.id]);

    useEffect(() => {
      // generate fresh player id if not set
      setPlayerId(prev => prev || randomId('p'));
    }, []);

    // Create room
    const createRoom = async () => {
      if (!playerName) { alert('Enter name first'); return; }
      const rid = randomId('room');
      const roomRef = db.ref(`rooms/${rid}`);
      const newRoom = {
        id: rid,
        name: `${playerName}'s Room`,
        players: { [playerId]: { id: playerId, name: playerName, cards: [], isReady: false } },
        maxPlayers: 4,
        createdBy: playerId
      };
      await roomRef.set(newRoom);
      setCurrentRoom(newRoom);
    };

    // Join room
    const joinRoom = async (rid) => {
      if (!playerName) { alert('Enter name first'); return; }
      const playerObj = { id: playerId, name: playerName, cards: [], isReady: false };
      await db.ref(`rooms/${rid}/players/${playerId}`).set(playerObj);
      // set local quickly (listener will update)
      setCurrentRoom(prev => ({ id: rid, ...prev }));
    };

    // Leave room
    const leaveRoom = async () => {
      if (!currentRoom) return;
      await db.ref(`rooms/${currentRoom.id}/players/${playerId}`).remove();
      // if room empty, delete
      const snap = await db.ref(`rooms/${currentRoom.id}/players`).once('value');
      if (!snap.exists()) await db.ref(`rooms/${currentRoom.id}`).remove();
      setCurrentRoom(null);
    };

    // Toggle ready (and auto-start if all ready)
    const toggleReady = async () => {
      if (!currentRoom) return;
      const myPath = `rooms/${currentRoom.id}/players/${playerId}/isReady`;
      const curr = (currentRoom.players && currentRoom.players[playerId] && currentRoom.players[playerId].isReady) || false;
      await db.ref(myPath).set(!curr);

      // re-check all ready (we'll do this after slight delay to ensure DB updated)
      setTimeout(async () => {
        const playersSnap = await db.ref(`rooms/${currentRoom.id}/players`).once('value');
        const players = playersSnap.val() || {};
        const ids = Object.keys(players);
        const allReady = ids.length >= 2 && ids.every(id => players[id].isReady);
        if (allReady) {
          startGame();
        }
      }, 300);
    };

    // Start game: build deck, deal, set gameState with turnOrder
    const startGame = async () => {
      if (!currentRoom) return;
      const deck = createDeck();
      const playersSnap = await db.ref(`rooms/${currentRoom.id}/players`).once('value');
      const players = playersSnap.val() || {};
      const playerIds = Object.keys(players);

      // deal 7 cards each
      const playersWithCards = {};
      playerIds.forEach(pid => {
        playersWithCards[pid] = { ...players[pid], cards: deck.splice(0,7) };
      });

      // take a non-wild top card
      let topCard = deck.pop();
      while (topCard && topCard.color === 'wild') {
        deck.unshift(topCard);
        topCard = deck.pop();
        if (!topCard) break;
      }
      if (!topCard) topCard = { id:'fallback-0', color:'red', type:'number', value:0 };

      const gameState = {
        currentPlayer: playerIds[0],
        direction: 'clockwise',
        topCard,
        currentColor: topCard.color,
        status: 'playing',
        drawPileCount: deck.length,
        players: playersWithCards,
        lastAction: 'Game started!',
        turnOrder: playerIds
      };

      await db.ref(`rooms/${currentRoom.id}`).update({
        gameState,
        drawPile: deck,
        discardPile: [topCard],
      });
    };

    // reshuffle discard -> draw if needed
    const reshuffleIfNeeded = async (rid) => {
      const drawSnap = await db.ref(`rooms/${rid}/drawPile`).once('value');
      const discardSnap = await db.ref(`rooms/${rid}/discardPile`).once('value');
      let drawPile = drawSnap.exists() ? drawSnap.val() : [];
      let discardPile = discardSnap.exists() ? discardSnap.val() : [];

      if ((!drawPile || drawPile.length === 0) && discardPile && discardPile.length > 1) {
        // keep last card (top)
        const newDraw = discardPile.slice(0, -1);
        const top = discardPile[discardPile.length -1];
        // shuffle newDraw
        for (let i = newDraw.length -1; i>0; i--){
          const j = Math.floor(Math.random()* (i+1));
          [newDraw[i], newDraw[j]] = [newDraw[j], newDraw[i]];
        }
        await db.ref(`rooms/${rid}`).update({
          drawPile: newDraw,
          'gameState/drawPileCount': newDraw.length,
          discardPile: [top]
        });
        return true;
      }
      return false;
    };

    const getNextPlayerIdLocal = (room, fromPlayerId = null, direction = null, skip = 0) => {
      if (!room || !room.gameState) return '';
      const turnOrder = room.gameState.turnOrder || Object.keys(room.gameState.players || {});
      const curr = fromPlayerId || room.gameState.currentPlayer;
      const dir = direction || room.gameState.direction;
      const step = dir === 'clockwise' ? 1 : -1;
      const idx = turnOrder.indexOf(curr);
      const nextIdx = (idx + step * (1 + skip) + turnOrder.length) % turnOrder.length;
      return turnOrder[nextIdx];
    };

    // draw card action
    const drawCard = async () => {
      if (!currentRoom || !currentRoom.gameState) return;
      if (currentRoom.gameState.currentPlayer !== playerId) return;

      // ensure drawPile exists, then pop
      let drawSnap = await db.ref(`rooms/${currentRoom.id}/drawPile`).once('value');
      let drawPile = drawSnap.exists() ? drawSnap.val() : [];
      if (!drawPile || drawPile.length === 0) {
        const resh = await reshuffleIfNeeded(currentRoom.id);
        if (!resh) return;
        // retry
        drawSnap = await db.ref(`rooms/${currentRoom.id}/drawPile`).once('value');
        drawPile = drawSnap.exists() ? drawSnap.val() : [];
        if (!drawPile || drawPile.length === 0) return;
      }

      const drawn = drawPile.pop();
      // add to player's hand
      const playerCards = (currentRoom.gameState.players[playerId].cards || []).concat([drawn]);

      // next player
      const nextId = getNextPlayerIdLocal(currentRoom);

      await db.ref(`rooms/${currentRoom.id}`).update({
        drawPile,
        'gameState/drawPileCount': drawPile.length,
        [`gameState/players/${playerId}/cards`]: playerCards,
        'gameState/currentPlayer': nextId,
        'gameState/lastAction': `${currentRoom.players[playerId].name} drew a card`
      });
    };

    // play card (handles wild selection)
    const onPlayCard = async (cardIndex) => {
      if (!currentRoom || !currentRoom.gameState) return;
      const player = currentRoom.gameState.players[playerId];
      const card = player.cards[cardIndex];
      if (!card) return;

      // check playable
      const top = currentRoom.gameState.topCard;
      const colorOk = card.color === 'wild' || card.color === currentRoom.gameState.currentColor;
      const numberOk = (card.type === 'number' && top.type === 'number' && card.value === top.value);
      const typeOk = (card.type === top.type && card.type !== 'number');
      const canPlay = colorOk || numberOk || typeOk;

      if (!canPlay) {
        setInvalidIndex(cardIndex);
        playSound('/sounds/error-beep.mp3');
        setTimeout(()=>setInvalidIndex(null), 450);
        return;
      }

      if (card.color === 'wild') {
        setSelectedCardIndex(cardIndex);
        setShowColorPicker(true);
        return;
      }

      // Otherwise actually play
      await actuallyPlayCard(cardIndex, card.color);
    };

    const actuallyPlayCard = async (cardIndex, chosenColor = null) => {
      if (!currentRoom || !currentRoom.gameState) return;

      const player = currentRoom.gameState.players[playerId];
      const card = player.cards[cardIndex];
      if (!card) return;

      // prepare playedCard (respect chosenColor for wild)
      const playedCard = chosenColor ? { ...card, color: chosenColor } : card;

      // visual flying effect
      setFlyingCard(playedCard);
      playSound('/sounds/card-swoosh.mp3');
      if (flyingTimeoutRef.current) clearTimeout(flyingTimeoutRef.current);
      flyingTimeoutRef.current = setTimeout(()=> setFlyingCard(null), 650);

      // remove from player's hand
      const newHand = player.cards.filter((_,i) => i !== cardIndex);

      // compute effects
      let skipCount = 0, drawCount = 0;
      let newDirection = currentRoom.gameState.direction;
      switch(card.type){
        case 'skip': skipCount = 1; break;
        case 'reverse': newDirection = newDirection === 'clockwise' ? 'counterclockwise' : 'clockwise'; break;
        case 'draw2': drawCount = 2; break;
        case 'wild4': drawCount = 4; break;
      }

      // next player index calculation (respecting newDirection and skip)
      const turnOrder = currentRoom.gameState.turnOrder || Object.keys(currentRoom.gameState.players);
      const step = newDirection === 'clockwise' ? 1 : -1;
      let currIndex = turnOrder.indexOf(playerId);
      let nextIndex = (currIndex + step + turnOrder.length) % turnOrder.length;
      if (skipCount > 0) nextIndex = (nextIndex + step + turnOrder.length) % turnOrder.length;
      const nextPlayerId = turnOrder[nextIndex];

      // apply draw to next player if any
      if (drawCount > 0) {
        // ensure draw pile available
        let drawSnap = await db.ref(`rooms/${currentRoom.id}/drawPile`).once('value');
        let drawPile = drawSnap.exists() ? drawSnap.val() : [];
        if (drawPile.length < drawCount) {
          await reshuffleIfNeeded(currentRoom.id);
          drawSnap = await db.ref(`rooms/${currentRoom.id}/drawPile`).once('value');
          drawPile = drawSnap.exists() ? drawSnap.val() : [];
        }

        const cardsToGive = drawPile.splice(-drawCount);
        const nextPlayerCards = (currentRoom.gameState.players[nextPlayerId].cards || []).concat(cardsToGive);

        await db.ref(`rooms/${currentRoom.id}`).update({
          [`gameState/players/${nextPlayerId}/cards`]: nextPlayerCards,
          drawPile,
          'gameState/drawPileCount': drawPile.length
        });
      }

      // push played card to discard pile and update state atomically (best-effort)
      const updates = {};
      updates[`gameState/topCard`] = playedCard;
      updates[`gameState/currentColor`] = playedCard.color;
      updates[`gameState/currentPlayer`] = nextPlayerId;
      updates[`gameState/players/${playerId}/cards`] = newHand;
      updates[`gameState/lastAction`] = `${currentRoom.players[playerId].name} played ${playedCard.color} ${playedCard.type}${playedCard.value ? ' ' + playedCard.value : ''}`;
      updates[`gameState/direction`] = newDirection;
      // append to discard pile (we'll read current discard in DB; this isn't strictly atomic but ok for demo)
      const curDiscardSnap = await db.ref(`rooms/${currentRoom.id}/discardPile`).once('value');
      const curDiscard = curDiscardSnap.exists() ? curDiscardSnap.val() : [];
      const newDiscard = (curDiscard || []).concat([playedCard]);
      updates['discardPile'] = newDiscard;

      await db.ref(`rooms/${currentRoom.id}`).update(updates);

      setShowColorPicker(false);
      setSelectedCardIndex(-1);

      // check win
      if (newHand.length === 0) {
        await db.ref(`rooms/${currentRoom.id}/gameState`).update({
          status: 'finished',
          winner: playerId,
          lastAction: `${currentRoom.players[playerId].name} wins!`
        });
      }
    };

    // UI rendering helpers
    const renderCardJSX = (card, idx, small=false) => {
      const top = currentRoom?.gameState?.topCard;
      const canPlay = currentRoom && (card.color === 'wild' || card.color === currentRoom.gameState.currentColor ||
                  (card.type === 'number' && top && top.type === 'number' && card.value === top.value) ||
                  (top && card.type === top.type && card.type !== 'number'));
      const style = {
        background: card.color === 'wild' ? '#111' : card.color,
        color: (card.color === 'yellow' || card.color === 'green') ? '#111' : '#fff'
      };
      const classes = `card ${small ? 'small':''} ${invalidIndex===idx ? 'invalid':''}`;
      return (
        <div key={card.id} className={classes} style={style}
          onClick={() => onPlayCard(idx)}
          title={`${card.color} ${card.type}${card.value ? ' '+card.value : ''}`}>
          <div>{card.type === 'number' ? card.value : (card.type==='skip'? '⛔': card.type==='reverse' ? '🔄' : card.type==='draw2' ? '+2' : card.type==='wild4' ? '+4' : '★')}</div>
        </div>
      );
    };

    // Small safety: if no currentRoom prompt to create/join
    if (!playerName) {
      return (
        <div className="max-w-md mx-auto bg-white rounded-xl p-6 shadow-xl text-center">
          <h1 className="text-2xl font-bold mb-3">UNO Multiplayer</h1>
          <input value={playerName} onChange={(e)=>setPlayerName(e.target.value)} className="w-full p-3 border rounded mb-3" placeholder="Enter your name"/>
          <div className="flex gap-2">
            <button onClick={createRoom} className="flex-1 bg-green-500 text-white py-2 rounded">Create Room</button>
            <button onClick={()=>{ const r = prompt('Room ID to join'); if(r) joinRoom(r); }} className="flex-1 bg-blue-500 text-white py-2 rounded">Join Room</button>
          </div>
          <p className="text-sm text-gray-500 mt-3">Or pick a name then create or join a room below.</p>
          <div className="mt-4 text-left">
            <h3 className="font-semibold">Available Rooms</h3>
            <div className="space-y-2 mt-2">
              {roomsList.length===0 ? <div className="text-gray-500">No rooms yet</div> : roomsList.map(r => (
                <div key={r.id} className="flex justify-between items-center border rounded p-2">
                  <div>
                    <div className="font-semibold">{r.name || r.id}</div>
                    <div className="text-xs text-gray-600">{Object.keys(r.players||{}).length} / {r.maxPlayers || 4}</div>
                  </div>
                  <button onClick={()=>joinRoom(r.id)} className="bg-blue-500 text-white px-3 py-1 rounded">Join</button>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    // If room exists and game finished
    if (currentRoom && currentRoom.gameState && currentRoom.gameState.status === 'finished') {
      const winnerId = currentRoom.gameState.winner;
      return (
        <div className="w-full max-w-4xl bg-white rounded-2xl p-6 shadow-xl">
          <h2 className="text-2xl font-bold mb-4">Game Over</h2>
          <p className="mb-4">{winnerId === playerId ? 'You won! 🎉' : `${currentRoom.players[winnerId]?.name || 'Someone'} won!`}</p>
          <button onClick={leaveRoom} className="bg-blue-500 text-white px-4 py-2 rounded">Return to Lobby</button>
        </div>
      );
    }

    // Main room UI (lobby or game)
    return (
      <div className="w-full max-w-6xl mx-auto space-y-6">
        {!currentRoom ? (
          <div className="bg-white rounded-2xl p-6 shadow-xl">
            <div className="flex items-center justify-between">
              <div>
                <h2 className="text-xl font-bold">Hello, {playerName}</h2>
                <p className="text-sm text-gray-600">Your ID: {playerId}</p>
              </div>
              <div className="flex gap-2">
                <button onClick={createRoom} className="bg-green-500 text-white px-4 py-2 rounded">Create Room</button>
                <input value={roomIdInput} onChange={(e)=>setRoomIdInput(e.target.value)} className="border rounded px-3 py-2" placeholder="Room ID"/>
                <button onClick={()=>joinRoom(roomIdInput)} className="bg-blue-500 text-white px-4 py-2 rounded">Join</button>
              </div>
            </div>

            <div className="mt-6">
              <h3 className="font-semibold mb-2">Available Rooms</h3>
              <div className="space-y-2">
                {roomsList.map(r => (
                  <div key={r.id} className="flex justify-between items-center p-2 border rounded">
                    <div>
                      <div className="font-semibold">{r.name || r.id}</div>
                      <div className="text-xs text-gray-600">{Object.keys(r.players||{}).length} players</div>
                    </div>
                    <div className="flex gap-2">
                      <button onClick={()=>joinRoom(r.id)} className="bg-blue-500 text-white px-3 py-1 rounded">Join</button>
                    </div>
                  </div>
                ))}
                {roomsList.length===0 && <div className="text-gray-500">No rooms yet</div>}
              </div>
            </div>
          </div>
        ) : (
          <div className="bg-white rounded-2xl p-6 shadow-xl relative">
            <div className="flex justify-between items-start">
              <div>
                <h2 className="text-xl font-bold mb-1">{currentRoom.name || currentRoom.id}</h2>
                <p className="text-sm text-gray-600">Players: {Object.keys(currentRoom.players||{}).length}</p>
              </div>

              <div className="flex gap-2">
                <button onClick={toggleReady} className="bg-green-500 text-white px-3 py-1 rounded">{ currentRoom.players[playerId] && currentRoom.players[playerId].isReady ? 'Not Ready' : 'Ready'}</button>
                <button onClick={leaveRoom} className="bg-red-500 text-white px-3 py-1 rounded">Leave</button>
                {!currentRoom.gameState && (<button onClick={startGame} className="bg-blue-500 text-white px-3 py-1 rounded">Start</button>)}
              </div>
            </div>

            {/* Game area */}
            { !currentRoom.gameState ? (
              <div className="mt-6">
                <h3 className="font-semibold mb-2">Waiting Room</h3>
                <div className="grid grid-cols-1 md:grid-cols-4 gap-3">
                  {Object.values(currentRoom.players || {}).map(p => (
                    <div key={p.id} className="border rounded p-3 text-center">
                      <div className="font-semibold">{p.name}{p.id===playerId ? ' (You)' : ''}</div>
                      <div className="text-sm text-gray-600">{p.isReady ? 'Ready ✅' : 'Not ready ❌'}</div>
                    </div>
                  ))}
                </div>
              </div>
            ) : (
              <div className="mt-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                {/* Left: game info + top card */}
                <div>
                  <div className="bg-gray-100 p-4 rounded mb-4">
                    <div><strong>Current:</strong> {currentRoom.gameState.currentPlayer ? (currentRoom.players[currentRoom.gameState.currentPlayer]?.name || currentRoom.gameState.currentPlayer) : '-'}</div>
                    <div><strong>Direction:</strong> {currentRoom.gameState.direction}</div>
                    <div><strong>Draw pile:</strong> {currentRoom.gameState.drawPileCount}</div>
                    <div className="text-sm text-gray-600 mt-2">{currentRoom.gameState.lastAction}</div>
                  </div>

                  <div className="bg-gray-100 p-4 rounded text-center">
                    <div className="mb-2 font-semibold">Top Card</div>
                    <div className="mx-auto top-card-area">
                      {currentRoom.gameState.topCard && (
                        <div style={{
                          width: '100%', height:'100%', display:'flex', alignItems:'center', justifyContent:'center'
                        }}>
                          {renderCardJSX(currentRoom.gameState.topCard, -1, false)}
                        </div>
                      )}
                    </div>

                    {/* flying card */}
                    {flyingCard && (
                      <div className="flying">
                        {renderCardJSX(flyingCard, 'flying', false)}
                      </div>
                    )}

                    <div className="mt-4">
                      <button onClick={drawCard} className="bg-blue-500 text-white px-4 py-2 rounded" disabled={currentRoom.gameState.currentPlayer !== playerId}>Draw Card</button>
                    </div>
                  </div>
                </div>

                {/* Right: player's hand + other players */}
                <div>
                  <div className="bg-gray-100 p-4 rounded mb-4">
                    <div className="mb-2 font-semibold">Your Cards</div>
                    <div className="flex flex-wrap gap-3">
                      {(currentRoom.gameState.players[playerId]?.cards || []).map((c, i) => renderCardJSX(c, i, true))}
                    </div>
                  </div>

                  <div className="bg-gray-100 p-4 rounded">
                    <div className="mb-2 font-semibold">Players</div>
                    <div className="grid grid-cols-1 gap-2">
                      {Object.values(currentRoom.gameState.players || {}).map(p => (
                        <div key={p.id} className={`p-2 rounded ${currentRoom.gameState.currentPlayer === p.id ? 'bg-blue-50 border border-blue-200' : ''}`}>
                          <div className="font-semibold">{currentRoom.players[p.id]?.name || p.id} {p.id===playerId ? '(You)' : ''}</div>
                          <div className="text-sm text-gray-600">Cards: {p.cards.length}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Color picker modal */}
            { showColorPicker && selectedCardIndex != null && (
              <div className="fixed inset-0 flex items-center justify-center backdrop">
                <div className="bg-white p-6 rounded-xl shadow-xl w-80 text-center">
                  <h3 className="font-bold mb-4">Choose color for Wild</h3>
                  <div className="grid grid-cols-2 gap-3">
                    <button onClick={()=>actuallyPlayCard(selectedCardIndex, 'red')} className="py-3 rounded bg-red-500 text-white">🔴 Red</button>
                    <button onClick={()=>actuallyPlayCard(selectedCardIndex, 'yellow')} className="py-3 rounded bg-yellow-400 text-black">🟡 Yellow</button>
                    <button onClick={()=>actuallyPlayCard(selectedCardIndex, 'green')} className="py-3 rounded bg-green-500 text-white">🟢 Green</button>
                    <button onClick={()=>actuallyPlayCard(selectedCardIndex, 'blue')} className="py-3 rounded bg-blue-500 text-white">🔵 Blue</button>
                  </div>
                  <div className="mt-3 text-sm">
                    <button onClick={()=>{ setShowColorPicker(false); setSelectedCardIndex(-1);} } className="text-gray-600">Cancel</button>
                  </div>
                </div>
              </div>
            )}

          </div>
        )}
      </div>
    );
  }

  ReactDOM.createRoot(document.getElementById('root')).render(<App />);

  </script>

  <!-- Notes:
    - Place your sound files in /sounds/card-swoosh.mp3 and /sounds/error-beep.mp3 relative to index.html.
    - This example uses Firebase compat SDK for simpler usage in an index.html; in production prefer modular imports and proper auth rules.
    - Tailwind CDN is used for quick styling; you may replace with your own CSS or a build setup.
    - This demo uses optimistic updates and not full conflict-resolution; it's suitable as a prototype.
  -->

</body>
</html>
